/* Author: Hao Wu 
 * A simple state machine language for specifying state machines.
 * 03-July-2020
 */
grammar StateMachine;
options {
    superClass = BaseParser;
    backtrack=true;
    memoize=true;
}

@header{
package org.nuim.cyclone.parser;
import java.util.Collections;
import java.util.Arrays;
import org.nuim.cyclone.parser.ast.*;
import org.nuim.cyclone.model.type.*;
import org.nuim.cyclone.model.value.*;
}

@lexer::header {
package org.nuim.cyclone.parser;
}

@lexer::members {
    private ParseErrorHandler fParseErrorHandler;

    public String getFilename() {
        return fParseErrorHandler.getFileName();
    }
    
    @Override
    public String getErrorHeader(RecognitionException e) {
    	return "line " + e.line + ":" + e.charPositionInLine;
    }
    	
    public void emitErrorMessage(String msg) {
        fParseErrorHandler.reportError(msg);
    }
 
    public void init(ParseErrorHandler handler) {
        fParseErrorHandler = handler;
    }
}

machine returns [ASTMachine machine]:

    MACHINE name=identifier {$machine = new ASTMachine( ((ASTIdentifier) name).identifier() );} LBRACE
        (v=globalVariableDecl {$machine.addVariable(v);})*
        (state)* (trans)*
        (invariantExpression)*
    RBRACE EOF
;

state:
    (stateModifier) ? STATE identifier LBRACE
        (localVariableDecl)*
        (expression SEMI)*
    RBRACE
;

trans: TRANS identifier LBRACE
        identifier ARROW identifier ON label
    RBRACE
;

invariantExpression:
    INVARIANT 
        (identifier) ? 
    LBRACE 
        (expression SEMI)+ 
    RBRACE
;

label:
    STRINGLITERAL
;

identifier returns [ASTExpression expr]:
    str=IDENT {$expr= new ASTIdentifier(str);}
;

stateModifier: 
      START 
    | FINAL
;

literal returns [ASTLiteral literal_node]:
      l=INTLITERAL {$literal_node=new ASTLiteral(ASTLiteral.LiteralType.INT,l);}
    | r=REALLITERAL {$literal_node=new ASTLiteral(ASTLiteral.LiteralType.REAL,r);}
    | b=BOOLLITERAL {$literal_node=new ASTLiteral(ASTLiteral.LiteralType.BOOL,b);}
    | s=STRINGLITERAL {$literal_node=new ASTLiteral(ASTLiteral.LiteralType.STRING,s);}
    | c=CHARLITERAL {$literal_node=new ASTLiteral(ASTLiteral.LiteralType.CHAR,c);}
;

globalVariableDecl returns [ASTVariable v]:
    t=type n=variableDeclarator {n.type=t;n.createVariable();$v=n;}
    SEMI
;

localVariableDecl :
    type variableDeclarator
    SEMI
;

modifier :
        'global'
    |   'native'
;

type returns [Type t] :
        p=primitiveType {$t=p;}
    |   e=enumType{$t=e;}
;

primitiveType returns [Type t]:
      INT {$t= new IntType();}
    | BOOL {$t=new BoolType();}
    | REAL {$t=new RealType();} 
    | STRING {$t=new StringType();}
;

enumType returns [EnumType t] :
    ENUM {$t=new EnumType();} LBRACE name=identifier {$t.add(name.toString());} 
    (COMMA l=identifier {$t.add(l.toString());})* RBRACE
;

variableDeclarator returns [ASTVariable var]:
    {$var=new ASTVariable();}
    n=identifier {$var.name=n.toString();}
    ('=' n=variableInitializer {$var.initializer=n;})? 
    (WHERE expression) ?
;

variableInitializer returns [ASTExpression expr]: 
        n=expression {$expr=n;}
    ;

expression returns [ASTExpression expr]:
        nOrExpr=conditionalOrExpression {$expr=$nOrExpr.expr;}
        (assignmentOperator nExpr=expression{$expr=nExpr;}
        )?
    ;

assignmentOperator 
    :   '='
;

conditionalOrExpression returns [ASTExpression expr]
    :   n=conditionalAndExpression {$expr=n;}
        ('||' conditionalAndExpression
        )*
    ;

conditionalAndExpression returns [ASTExpression expr]
    :
     n=relationalExpression {$expr=n;}
     ('&&' relationalExpression
        )*
    ;

relationalExpression returns [ASTExpression expr]
    : n=additiveExpression {$expr=n;}
        (relationalOp additiveExpression
        )*
;

relationalOp 
    :    '<=' 
    |    '>='
    |   '<'
    |   '>'
    ;

additiveExpression returns [ASTExpression expr]
    :   n=multiplicativeExpression {$expr=n;}
        (   
            (   '+'
            |   '-'
            )
            multiplicativeExpression
         )*
    ;

multiplicativeExpression returns [ASTExpression expr]
    :
        n=unaryExpression {$expr=n;}
        (   
            (   '*'
            |   '/'
            |   '%'
            )
            unaryExpression
        )*
    ;

unaryExpression returns [ASTExpression expr]
    :   '+'  unaryExpression
    |   '-' unaryExpression
    |   '++' unaryExpression
    |   '--' unaryExpression
    |   n=unaryExpressionNotPlusMinus {$expr=n;}
    ;

unaryExpressionNotPlusMinus returns [ASTExpression expr]
    :   '!' unaryExpression
    |   p=primary {$expr=p;}
    ;

primary returns [ASTExpression expr]
    :   parExpression 
    |   identifier
    |   literExpr=literal {$expr=literExpr;}
    ;

parExpression returns [ASTExpression expr]
    :   '(' expression ')'
    ;